//
// Created by parallels on 1/30/20.
//

#include "ros/ros.h"
#include "std_msgs/String.h"
#include "nav_msgs/OccupancyGrid.h"
#include <sstream>
#include "../include/my_frontier_exploration/frontier_search.h"
#include <visualization_msgs/Marker.h>
#include <visualization_msgs/MarkerArray.h>
#include <rviz_visual_tools/rviz_visual_tools.h>
#include "std_msgs/Bool.h"
#include "../include/my_frontier_exploration/inflation_obstacle_builder.h"
#include "../include/Config/Config.h"

ros::Publisher pub;
ros::Publisher marker_pub;
ros::Publisher markerArray_pub;
ros::Publisher frontierpub;
frontier_search* frontierSearch;
bool firstmapstored = false;//at least one map is stored
std::vector<double> markerarrayx;// for display
std::vector<double> markerarrayy;//for display
inflation_obstacle_builder builder;
vector<double> StartingPosforFillingx ;//record the coord of the starting pos of the whole program for filling the map
vector<double> StartingPosforFillingy ;
std::vector<int>  coord_to_grid(std::vector<double> coord, nav_msgs::OccupancyGrid* map);


void FillMap(nav_msgs::OccupancyGrid* map){//fill the map each time before find the frontier
    vector<std::vector<double>> currentposori = frontierSearch->get_pos_ori("base_link");
    StartingPosforFillingx.push_back(currentposori[0][0]);
    StartingPosforFillingy.push_back(currentposori[0][1]);
    for(int k = 0 ; k < StartingPosforFillingy.size(); k++){
        vector<double> coordXY;
        coordXY.push_back(StartingPosforFillingx[k]);
        coordXY.push_back(StartingPosforFillingy[k]);
        vector<int> mapXY = coord_to_grid(coordXY,map);
        for(int i = -4; i <= 4 ; i++){
            for(int j = -4 ; j <= 4; j++){
                map->data[(mapXY[0]+i) + (mapXY[1]+j)*map->info.width] = 0;
            }
        }
    }

    return;

}

void init_marker(frontier_search::frontier closet_frontier){
    int gridXY[2] = {frontierSearch->closet_frontier.centroid.x , frontierSearch->closet_frontier.centroid.y};
    std::vector<double > mapXY;
    mapXY = frontierSearch->grid_to_coord(gridXY);
    visualization_msgs::Marker marker;
    marker.header.frame_id = "map";
    marker.header.stamp = ros::Time::now();
    marker.id = 10000;
    marker.type = visualization_msgs::Marker::CUBE;
    marker.action = visualization_msgs::Marker::ADD;
    marker.pose.position.x = mapXY[0];
    marker.pose.position.y = mapXY[1];
    marker.pose.position.z = 0;
    marker.pose.orientation.x = 0.0;
    marker.pose.orientation.y = -0.7071;
    marker.pose.orientation.z = 0.0;
    marker.pose.orientation.w = 0.7071;
    marker.scale.x = 0.2;
    marker.scale.y = 0.2;
    marker.scale.z = 0.2;
    marker.color.r = 1.0f;
    marker.color.g = 0.0f;
    marker.color.b = 0.0f;
    marker.color.a = 1.0;
    marker.lifetime = ros::Duration();
    marker_pub.publish(marker);
    std::cout<<"****** pub marker *******"<<std::endl;
}
void init_pub_markerarray(frontier_search* frontierSearch){
    // clear all the marker
    visualization_msgs::MarkerArray ma;
    for(int i =0 ;i< markerarrayx.size();i++){
        visualization_msgs::Marker marker;
        marker.header.frame_id = "map";
        marker.header.stamp = ros::Time::now();
        marker.id = i + 100;//avoid to have same ids with the marker of path generated by move_base
        marker.type = visualization_msgs::Marker::CUBE;
        marker.action = visualization_msgs::Marker::DELETE;
        marker.pose.position.x = markerarrayx[i];
        marker.pose.position.y = markerarrayy[i];
        marker.pose.position.z = 0;
        marker.pose.orientation.x = 0.0;
        marker.pose.orientation.y = -0.7071;
        marker.pose.orientation.z = 0.0;
        marker.pose.orientation.w = 0.7071;
        marker.scale.x = 0.1;
        marker.scale.y = 0.1;
        marker.scale.z = 0.1;
        marker.color.r = 1.0f;
        marker.color.g = 0.0f;
        marker.color.b = 0.0f;
        marker.color.a = 1.0;
        marker.lifetime = ros::Duration();
        ma.markers.push_back(marker);
    }
    markerArray_pub.publish(ma);
    ma.markers.clear();
    markerarrayx.clear();
    markerarrayy.clear();

    if(frontierSearch->frontiers.size() == 0){//frontiers_pool
        std::cout<<"no frontiers"<<std::endl;
    }else{
        visualization_msgs::MarkerArray ma;
        for (int j = 0; j < frontierSearch->frontiers.size(); ++j) {
            int gridXY[2] = {frontierSearch->frontiers[j].centroid.x , frontierSearch->frontiers[j].centroid.y};
            std::vector<double > mapXY;
            mapXY = frontierSearch->grid_to_coord(gridXY);
            visualization_msgs::Marker marker;
            marker.header.frame_id = "map";
            marker.header.stamp = ros::Time::now();
            marker.id = j + 100;//avoid to have same ids with the marker of path generated by move_base
            marker.type = visualization_msgs::Marker::CUBE;
            marker.action = visualization_msgs::Marker::ADD;
            marker.pose.position.x = mapXY[0];
            marker.pose.position.y = mapXY[1];
            markerarrayx.push_back(mapXY[0]);
            markerarrayy.push_back(mapXY[1]);
            marker.pose.position.z = 0;
            marker.pose.orientation.x = 0.0;
            marker.pose.orientation.y = -0.7071;
            marker.pose.orientation.z = 0.0;
            marker.pose.orientation.w = 0.7071;
            marker.scale.x = 0.1;
            marker.scale.y = 0.1;
            marker.scale.z = 0.1;
            marker.color.r = 1.0f;
            marker.color.g = 0.0f;
            marker.color.b = 0.0f;
            marker.color.a = 1.0;
            marker.lifetime = ros::Duration();
            ma.markers.push_back(marker);
        }
        markerArray_pub.publish(ma);
        ma.markers.clear();
    }

}



void FinishedCallback(const std_msgs::Bool finished){

    cout<<"finished start .............."<<endl;
    if(finished.data == true){
        if( firstmapstored == false){ return;}
        FillMap(&builder.newest_map);
        builder.set_obstacle_space();
        builder.set_obstacle_edge_vec();
        builder.inflation();
        cout<<"!!!!!!!!!!!!!!!!!inflation start"<<endl;
        frontierSearch->map = builder.inflation_map;
        frontierSearch->frontier_edge_cells = frontierSearch->get_frontier_edge_cells(frontierSearch->map);

        frontierSearch->frontier_regions = frontierSearch->get_frontier_regions(
                frontierSearch->frontier_edge_cells);
        frontierSearch->frontiers = frontierSearch->get_frontiers(frontierSearch->frontier_regions);
        std::cout<<"new comes frontiers : "<<frontierSearch->frontiers.size()<<std::endl;
        // get frontier from dfs #################
        frontierSearch->build_dfs(frontierSearch->frontiers);
        frontierSearch->closet_frontier = frontierSearch->get_frontier_based_on_dfs(builder);
        // #################get frontier from dfs

        // get closest frontier not from frontiers_pool  #################
/*
        frontierSearch->closet_frontier = frontierSearch->get_closest_frontier_direct(frontierSearch->frontiers,builder);
*/
        //  #################get closest frontier not from frontiers_pool


        //get closest frontier from frontiers_pool #################
/*        if(frontierSearch->frontiers.size() != 0 ){
            frontierSearch->frontiers_pool.insert(std::end(frontierSearch->frontiers_pool),
                                                  std::begin(frontierSearch->frontiers), std::end(frontierSearch->frontiers));
        }
        std::cout<<"size of frontiers_pool before map update : "<<frontierSearch->frontiers_pool.size()<<std::endl;
        frontierSearch->closet_frontier = frontierSearch->get_closest_frontier(&(frontierSearch->frontiers_pool),builder);
        std::cout<<"size of frontiers_pool after map update and minus 1(closest) : "<<frontierSearch->frontiers_pool.size()<<std::endl;
*/
        //#################get closest frontier from frontiers_pool


        for (int i = 0; i < frontierSearch->frontiers.size(); ++i) {
            for (int j = 0; j < frontierSearch->frontiers[i].vector.size(); ++j) {
                frontierSearch->map.data[frontierSearch->frontiers[i].vector[j].index] = (i + 1) * 9;
            }
        }
        init_pub_markerarray(frontierSearch);
        init_marker(frontierSearch->closet_frontier);
//        pub.publish(frontierSearch->map);

//        pub.publish(builder.inflation_map);

        geometry_msgs::Point frontier;
        int gridXY[2] = {frontierSearch->closet_frontier.centroid.x , frontierSearch->closet_frontier.centroid.y};
        std::vector<double > mapXY;
        mapXY = frontierSearch->grid_to_coord(gridXY);
        frontier.x = mapXY[0];
        frontier.y = mapXY[1];
        frontierpub.publish(frontier);
    }
    cout<<"..............finished end "<<endl;

}


void MapCallback(const nav_msgs::OccupancyGrid::ConstPtr map)
{
    cout<<"map start ######################"<<endl;

    if (  std::equal(map->data.begin() + 1, map->data.end(), map->data.begin()) )// true -> map is all -1
    {
    } else {
        firstmapstored = true;//at least one map is stored
        builder.newest_map = *map;
    }
    cout<<"###################### map end "<<endl;
}
void ReadyCallback(const std_msgs::String ready){

}
void NoPathFoundCallback(const std_msgs::Bool no_path_found){
    if(no_path_found.data == true){
        // get closest frontier from frontiers_pool  #################
/*        FillMap(&builder.newest_map);
        builder.set_obstacle_space();
        builder.set_obstacle_edge_vec();
        builder.inflation();

        frontierSearch->map = builder.inflation_map;
        frontierSearch->frontier_edge_cells = frontierSearch->get_frontier_edge_cells(frontierSearch->map);

        frontierSearch->frontier_regions = frontierSearch->get_frontier_regions(
                frontierSearch->frontier_edge_cells);
        frontierSearch->frontiers = frontierSearch->get_frontiers(frontierSearch->frontier_regions);
        std::cout<<"new comes frontiers : "<<frontierSearch->frontiers.size()<<std::endl;
        frontierSearch->closet_frontier  = frontierSearch->get_closest_frontier_direct(frontierSearch->frontiers,builder);
*/
        // ################# get closest frontier from frontiers_pool




        // get closest frontier from frontiers_pool  #################
/*
        frontierSearch->closet_frontier = frontierSearch->get_closest_frontier(&(frontierSearch->frontiers_pool),builder);
*/
        // ################# get closest frontier from frontiers_pool

        if(frontierSearch->frontiers.size() == 0){
            cout<<"no more frontier can be provided .. Goodbye"<<endl;
            return;
        }

        // get frontier from dfs #################
        frontierSearch->closet_frontier = frontierSearch->get_frontier_based_on_dfs(builder);
        // #################get frontier from dfs

        init_pub_markerarray(frontierSearch);
        init_marker(frontierSearch->closet_frontier);
        pub.publish(builder.inflation_map);
        geometry_msgs::Point frontier;
        int gridXY[2] = {frontierSearch->closet_frontier.centroid.x , frontierSearch->closet_frontier.centroid.y};
        std::vector<double > mapXY;
        mapXY = frontierSearch->grid_to_coord(gridXY);
        frontier.x = mapXY[0];
        frontier.y = mapXY[1];
        frontierpub.publish(frontier);
        cout<<"second frontier is provided because the first frontier can not be reached !"<<endl;
    }
}

int main(int argc, char **argv)
{

    ros::init(argc, argv, "frontier_exploration");
    ros::NodeHandle n;
    ros::Subscriber sub = n.subscribe("map", 1000, MapCallback);
    ros::Subscriber subfinished = n.subscribe("finished", 1000, FinishedCallback);
    ros::Subscriber sub_ready = n.subscribe("ready", 1000, ReadyCallback);
    ros::Subscriber sub_no_path_found = n.subscribe("no_path_found",1000,NoPathFoundCallback);
    pub = n.advertise<nav_msgs::OccupancyGrid>("my_test_map", 1000);
    marker_pub = n.advertise<visualization_msgs::Marker>("visualization_marker", 1);
    markerArray_pub = n.advertise<visualization_msgs::MarkerArray>("MarkerArray", 10);
    frontierpub = n.advertise<geometry_msgs::Point>("frontier", 1000);
    ros::Rate loop_rate(10);
    frontierSearch = new frontier_search();
    builder = *new inflation_obstacle_builder();
    while(ros::ok())
    {
        ros::spinOnce();
        loop_rate.sleep();
    }


    return 0;
}

std::vector<int>  coord_to_grid(std::vector<double> coord, nav_msgs::OccupancyGrid* map){
    double origin_x = map->info.origin.position.x;
    double origin_y = map->info.origin.position.y;
    double origin_z = map->info.origin.position.z;
    double q1 = map->info.origin.orientation.x;
    double q2 = map->info.origin.orientation.y;
    double q3 = map->info.origin.orientation.z;
    double q0 = map->info.origin.orientation.w;

    Eigen::MatrixXd H(4,4);
    H << 1 - 2*q2*q2 - 2*q3*q3 , 2*q1*q2 - 2*q0*q3 , 2*q1*q3 + 2*q0*q2 , origin_x,
            2*q1*q2 + 2*q0*q3 , 1 - 2*q1*q1 - 2*q3*q3 , 2*q2*q3 - 2*q0*q1 , origin_y,
            2*q1*q3 - 2*q0*q2 , 2*q2*q3 + 2*q0*q1 , 1 - 2*q1*q1 - 2*q2*q2 , origin_z,
            0,0,0,1;
    Eigen::VectorXd map_xy(4,1);
    map_xy << coord[0] ,
            coord[1] ,
            0 ,
            1;
    Eigen::VectorXd grid_xy(4,1);
    grid_xy = H.inverse() * map_xy / map->info.resolution;

    vector<int > gridXY;
    gridXY.push_back(int(grid_xy(0,0)));
    gridXY.push_back(int(grid_xy(1,0)));

    return gridXY;
}